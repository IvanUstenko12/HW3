from math import log2, floor
def func(s, p):
    global otv, f, n
    if len(s) == 1: #если дерево состоит из одной вершины, смотрим значение в ней, если оно равно нужному, добавляем путь в ответ
        if s[0] == n:
            otv.append(p)
    else:
        s1 = []
        s2 = []
        #разделяем дерево на левую и правую часть (s1 и s2 соответственно)
        for i in range (1, f - len(p) + 1):
            for k in range(2**(i-1)): 
                s1.append(s[2**i - 1 + k])
            for k in range(2**(i-1), 2**i):
                s2.append(s[2**i - 1 + k])
        p1 = p.copy()
        p2 = p.copy()
        if s1[0] != '': 
            #запускаем функцию от левого дерева, к корню которого прибавили корень исходного дерева
            p1.append(s1[0])
            s1[0] += s[0]
            func(s1, p1)
        if s2[0] != '':
            #запускаем функцию от правого дерева, к корню которого прибавили корень исходного дерева
            p2.append(s2[0])
            s2[0] += s[0]
            func(s2, p2)

otv = []
s = input().split(',')
for i in range(len(s)):
    if s[i].isdigit():
        s[i] = int(s[i])     
i = 0  
#с помощью введеных данных надо построить дерево вида [v1_1, v2_1, v2_2, v3_1, v3_2...], где vi_k - значение k-ой вершины на i-ом уровне 
#если вершины не существует, то vi_k = ''; на каждом уровне должно быть хотя бы одно численное значение
while len(s) > 2**(i + 1):
    for k in range(2**i - 1, 2**(i + 1) - 1):
        if s[k] == '': #если значение в вершине = '', то задаём её детям значения ''
            s.insert(2*k + 1, '')
            s.insert(2*k + 2, '')
    i += 1
for _ in range(len(s) - 2**floor(log2(len(s) + 1)) + 1): #обрезаем нижний уровень, состоящий только из несуществующих вершин
    del s[-1]
f = floor(log2(len(s) + 1)) #считаем количество уровней
n = int(input())
func(s, [s[0]])
for i in range(len(otv)):
    sa = otv[i].copy()
    for k in range(len(sa)):
        sa[k] = str(sa[k])
    print('->'.join(sa))
